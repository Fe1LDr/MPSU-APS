reg[1] <- 32 // загрузить константу '32' в регистр 1
reg[2] <- sw_i // загрузить значение с входа sw_i в регистр 2
reg[3] <- 0 // загрузить константу '32' в регистр 3
reg[4] <- 32
reg[5] <- 1

if reg[3] < 32
	if (reg[2] & (1 << reg[3])) > 0
		reg[1] <- reg[3]
	reg[3] <- reg[3] + reg[5]
	PC <- PC - 8

out_o = reg[1], PC <- PC + reg[0]

0  000000100000  00000 000 00001 0010011
4  000000001000  00000 000 00010 0010011
8  000000000001  00000 000 00011 0010011
C  000000100000  00000 000 00100 0010011
10 000000000001  00000 000 00101 0010011
14 0000000 00100 00011 100 01000 1100011 // if 1
18 00000010000000000000    01111 1101111 // else 1
1С 0000000 00011 00101 001 00110 0110011
20 0000000 00110 00010 111 00110 0110011
24 0000000 00110 00000 100 01000 1100011
28 00000000100000000000    01111 1101111 // else 1
2С 0000000 00011 00000 000 00001 0110011
30 0000000 00101 00011 000 00011 0110011
34 000000010100  00000 000 01111 1100111
38 00000000000000000000    01111 1101111

// J B WS ALUop  RA1   RA2   const     WA
0  0 0 00   00000000000000000100000  00001 // reg[1] = 32
4  0 0 10   00000000000000000000000  00010 // reg[2] = sw_i
8  0 0 00   00000000000000000000000  00011 // reg[3] = 0
С  0 0 00   00000000000000000100000  00100 // reg[4] = 32
10 0 0 00   00000000000000000000001  00101 // reg[5] = 1
14 0 1 00 11110 00011 00100 00000010 00000 // if 1
18 1 0 00 00000 00000 00000 00001000 00000 // else 1
1С 0 0 01 00001 00101 00011 00000000 00110 // if 2
20 0 0 01 00111 00010 00110 00000000 00110 // if 2
24 0 1 00 11110 00000 00110 00000010 00000 // if 2
28 1 0 00 00000 00000 00000 00000010 00000 // else 2
2С 0 0 01 00000 00011 00000 00000000 00001 // блок if 2 / if 1
30 0 0 01 00000 00011 00101 00000000 00011 // блок if 1
34 1 0 00 00000 00000 00000 11111000 00000 // блок if 2
38 1 0 00 00000 00001 00000 00000000 00000 // out_o
  
  